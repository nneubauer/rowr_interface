#!/usr/bin/env ruby

require 'rowr_interface'
require 'unirest'
require 'descriptive_statistics'

class WorkoutTracker

  BASE_URL = 'http://192.168.0.10:3000'
  
  BUCKET_SIZE_IN_SECONDS = 10 #seconds

  def initialize
    @interface = RowrInterface.new
    
    # each element in the buckets collects one minute of data
    @buckets = []
    @current_bucket = {}
    @data_mutex = Monitor.new
    @send_queue = []
    @queue_mutex = Monitor.new
  end
  
  def start
    liste_thread = start_listening!
    query_thread = start_querying!
    bucket_thread = aggregate_to_buckets!
    data_thread = post_data!
    
    liste_thread.join
    query_thread.join
    bucket_thread.join
    data_thread.join
  end
  
  protected
  
  # Adds data threadsafe to @current_bucket
  def add_data(type, value)
    @data_mutex.synchronize do
      @current_bucket[type] ||= []
      @current_bucket[type] << value
      
      #puts "Added data: " + @current_bucket.inspect
    end
  end
  
  # Calculates the mean of the middle 90% of data
  def mean_without_outliers(values)
    lower_limit = values.percentile(5)
    upper_limit = values.percentile(95)
    
    puts "Cleaning data: " + values.inspect
    puts "Lower: " + lower_limit.to_s + ", upper: " + upper_limit.to_s
    
    values.select { |v| v <= upper_limit && v >= lower_limit }.mean
  end
  
  # creates a list of samples of a bucket, each element is immutable
  def bucket_to_list_of_samples(bucket)
    list = []
        
    #Average types
    [:pull_time, :rest_time, :stroke_to_stroke_time].each do |type|
      values = bucket[:data][type]
      unless values.nil?
        list << {sample: {
          start: bucket[:start_date],
          end: bucket[:end_date],
          sample_type: type,
          quantity: mean_without_outliers(values)
          }}.freeze
        puts "Just added a sample " + list.last.inspect
      end
    end
    
    [:current_energy, :current_speed].each do |type|
      values = bucket[:data][type]
      unless values.nil?
        list << {sample: {
          start: bucket[:start_date],
          end: bucket[:end_date],
          sample_type: type.to_s.sub("current", "average"),
          quantity: mean_without_outliers(values)
          }}.freeze
        puts "Just added a sample " + list.last.inspect
      end
    end
    
    #Diff types
    [:total_distance, :total_calories].each do |type|
      values = bucket[:data][type]
      unless values.nil?
        list << {sample: {
          start: bucket[:start_date],
          end: bucket[:end_date],
          sample_type: type,
          quantity: values.max - values.min
          }}.freeze
        puts "Just added a sample " + list.last.inspect
      end
    end
    
    #count_types
    values = bucket[:data][:stroke_to_stroke_time]
    unless values.nil?
      list << {sample: {
        start: bucket[:start_date],
        end: bucket[:end_date],
        sample_type: :strokes,
        quantity: values.size
        }}.freeze
      puts "Just added a sample " + list.last.inspect
    end
    
    list
  end
  
  def enqueue_buckets
    @data_mutex.synchronize do
    
      if @buckets.size >= 1
        puts "Training more than 5 buckets. Posting pending buckets."
        
        @buckets.select { |b| !b[:posted] }.each do |bucket|

          bucket_to_list_of_samples(bucket).each do |sample|
            @queue_mutex.synchronize do 
              @send_queue << sample
            end
          end
          
          bucket[:posted] = true
        end        
      else
        puts "Not enough buckets to enqueue for posting: " + @buckets.size
      end
      
      
    end    
  end
  
  def post_data!
    Thread.new do
      while true
        sleep(1)
      
        @queue_mutex.synchronize do
        
          if !@send_queue.empty?
            data = @send_queue.pop
            
            puts "About to post: " + data.inspect
            
            response = Unirest.post(BASE_URL + "/samples",
              headers: {"Content-Type" => "application/json"},
              parameters: data.to_json,
              auth: { user: "test", password: "test" }
            )
          
            if !true #todo check response status, back to queue if unsuccessful
              @send_queue.push(data)
            end
          end 
        end       
      end
    end
  end
    
  def aggregate_to_buckets!
    Thread.new do 
      while true
        sleep BUCKET_SIZE_IN_SECONDS
                
        @data_mutex.synchronize do
          if @current_bucket.size > 0
            
            #clean buckets if the current bucket is not adjacent
            if @buckets.size > 0 and @buckets.last[:end_date] + (BUCKET_SIZE_IN_SECONDS + BUCKET_SIZE_IN_SECONDS * 0.5) < Time.now
              puts "Cleaning out buckets, because last one is more than 90 seconds ago."
              @buckets = []
            end
            
            resulting_bucket = {start_date: Time.now, end_date: Time.now - BUCKET_SIZE_IN_SECONDS, data: @current_bucket}
            
            puts "Adding new bucket to backlist: " + resulting_bucket.inspect
            
            @buckets << resulting_bucket
            @current_bucket = {}
            
            enqueue_buckets
          end
        end
        
      end
    end
  end
  
  def start_querying!
    Thread.new do 
      while true
        sleep 1.0
        data = @interface.current_status
        
        data.each do |key, value|
          add_data(key, value)
        end
      end
    end
  end
  
  def start_listening!
    
    last_stroke_notification = Time.now
    
    t = @interface.start do |pull_time|
      #calculate stroke to stroke
      stroke_to_stroke_time = Time.now - last_stroke_notification
      last_stroke_notification = Time.now
      
      add_data(:stroke_to_stroke_time, stroke_to_stroke_time)
      add_data(:pull_time, pull_time)
      add_data(:rest_time, stroke_to_stroke_time - pull_time)    
    end  
    
    t
  end
  
end

WorkoutTracker.new.start